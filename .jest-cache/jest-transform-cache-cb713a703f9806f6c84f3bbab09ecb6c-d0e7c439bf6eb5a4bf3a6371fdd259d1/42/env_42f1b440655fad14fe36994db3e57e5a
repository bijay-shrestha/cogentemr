0df9ed68ce836f1baa20a5146d357588
'use strict';

var fs = require('fs');

var path = require('path');

var paths = require('./paths'); // Make sure that including paths.js after env.js will read .env variables.


delete require.cache[require.resolve('./paths')];
var NODE_ENV = process.env.NODE_ENV;

if (!NODE_ENV) {
  throw new Error('The NODE_ENV environment variable is required but was not specified.');
} // https://github.com/bkeepers/dotenv#what-other-env-files-can-i-use


var dotenvFiles = ["".concat(paths.dotenv, ".").concat(NODE_ENV, ".local"), "".concat(paths.dotenv, ".").concat(NODE_ENV), // Don't include `.env.local` for `test` environment
// since normally you expect tests to produce the same
// results for everyone
NODE_ENV !== 'test' && "".concat(paths.dotenv, ".local"), paths.dotenv].filter(Boolean); // Load environment variables from .env* files. Suppress warnings using silent
// if this file is missing. dotenv will never modify any environment variables
// that have already been set.  Variable expansion is supported in .env files.
// https://github.com/motdotla/dotenv
// https://github.com/motdotla/dotenv-expand

dotenvFiles.forEach(function (dotenvFile) {
  if (fs.existsSync(dotenvFile)) {
    require('dotenv-expand')(require('dotenv').config({
      path: dotenvFile
    }));
  }
}); // We support resolving modules according to `NODE_PATH`.
// This lets you use absolute paths in imports inside large monorepos:
// https://github.com/facebook/create-react-app/issues/253.
// It works similar to `NODE_PATH` in Node itself:
// https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders
// Note that unlike in Node, only *relative* paths from `NODE_PATH` are honored.
// Otherwise, we risk importing Node.js core modules into an app instead of Webpack shims.
// https://github.com/facebook/create-react-app/issues/1023#issuecomment-265344421
// We also resolve them to make sure all tools using them work consistently.

var appDirectory = fs.realpathSync(process.cwd());
process.env.NODE_PATH = (process.env.NODE_PATH || '').split(path.delimiter).filter(function (folder) {
  return folder && !path.isAbsolute(folder);
}).map(function (folder) {
  return path.resolve(appDirectory, folder);
}).join(path.delimiter); // Grab NODE_ENV and REACT_APP_* environment variables and prepare them to be
// injected into the application via DefinePlugin in Webpack configuration.

var REACT_APP = /^REACT_APP_/i;

function getClientEnvironment(publicUrl) {
  var raw = Object.keys(process.env).filter(function (key) {
    return REACT_APP.test(key);
  }).reduce(function (env, key) {
    env[key] = process.env[key];
    return env;
  }, {
    // Useful for determining whether weâ€™re running in production mode.
    // Most importantly, it switches React into the correct mode.
    NODE_ENV: process.env.NODE_ENV || 'development',
    // Useful for resolving the correct path to static assets in `public`.
    // For example, <img src={process.env.PUBLIC_URL + '/img/logo.png'} />.
    // This should only be used as an escape hatch. Normally you would put
    // images into the `src` and `import` them in code to get their paths.
    PUBLIC_URL: publicUrl
  }); // Stringify all values so we can feed into Webpack DefinePlugin

  var stringified = {
    'process.env': Object.keys(raw).reduce(function (env, key) {
      env[key] = JSON.stringify(raw[key]);
      return env;
    }, {})
  };
  return {
    raw: raw,
    stringified: stringified
  };
}

module.exports = getClientEnvironment;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVudi5qcyJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwicGF0aHMiLCJjYWNoZSIsInJlc29sdmUiLCJOT0RFX0VOViIsInByb2Nlc3MiLCJlbnYiLCJFcnJvciIsImRvdGVudkZpbGVzIiwiZG90ZW52IiwiZmlsdGVyIiwiQm9vbGVhbiIsImZvckVhY2giLCJkb3RlbnZGaWxlIiwiZXhpc3RzU3luYyIsImNvbmZpZyIsImFwcERpcmVjdG9yeSIsInJlYWxwYXRoU3luYyIsImN3ZCIsIk5PREVfUEFUSCIsInNwbGl0IiwiZGVsaW1pdGVyIiwiZm9sZGVyIiwiaXNBYnNvbHV0ZSIsIm1hcCIsImpvaW4iLCJSRUFDVF9BUFAiLCJnZXRDbGllbnRFbnZpcm9ubWVudCIsInB1YmxpY1VybCIsInJhdyIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJ0ZXN0IiwicmVkdWNlIiwiUFVCTElDX1VSTCIsInN0cmluZ2lmaWVkIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLElBQU1BLEVBQUUsR0FBR0MsT0FBTyxDQUFDLElBQUQsQ0FBbEI7O0FBQ0EsSUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxJQUFNRSxLQUFLLEdBQUdGLE9BQU8sQ0FBQyxTQUFELENBQXJCLEMsQ0FFQTs7O0FBQ0EsT0FBT0EsT0FBTyxDQUFDRyxLQUFSLENBQWNILE9BQU8sQ0FBQ0ksT0FBUixDQUFnQixTQUFoQixDQUFkLENBQVA7QUFFQSxJQUFNQyxRQUFRLEdBQUdDLE9BQU8sQ0FBQ0MsR0FBUixDQUFZRixRQUE3Qjs7QUFDQSxJQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNiLFFBQU0sSUFBSUcsS0FBSixDQUNKLHNFQURJLENBQU47QUFHRCxDLENBRUQ7OztBQUNBLElBQUlDLFdBQVcsR0FBRyxXQUNiUCxLQUFLLENBQUNRLE1BRE8sY0FDR0wsUUFESCx1QkFFYkgsS0FBSyxDQUFD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Y29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHBhdGhzID0gcmVxdWlyZSgnLi9wYXRocycpO1xuXG4vLyBNYWtlIHN1cmUgdGhhdCBpbmNsdWRpbmcgcGF0aHMuanMgYWZ0ZXIgZW52LmpzIHdpbGwgcmVhZCAuZW52IHZhcmlhYmxlcy5cbmRlbGV0ZSByZXF1aXJlLmNhY2hlW3JlcXVpcmUucmVzb2x2ZSgnLi9wYXRocycpXTtcblxuY29uc3QgTk9ERV9FTlYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcbmlmICghTk9ERV9FTlYpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdUaGUgTk9ERV9FTlYgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgcmVxdWlyZWQgYnV0IHdhcyBub3Qgc3BlY2lmaWVkLidcbiAgKTtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JrZWVwZXJzL2RvdGVudiN3aGF0LW90aGVyLWVudi1maWxlcy1jYW4taS11c2VcbnZhciBkb3RlbnZGaWxlcyA9IFtcbiAgYCR7cGF0aHMuZG90ZW52fS4ke05PREVfRU5WfS5sb2NhbGAsXG4gIGAke3BhdGhzLmRvdGVudn0uJHtOT0RFX0VOVn1gLFxuICAvLyBEb24ndCBpbmNsdWRlIGAuZW52LmxvY2FsYCBmb3IgYHRlc3RgIGVudmlyb25tZW50XG4gIC8vIHNpbmNlIG5vcm1hbGx5IHlvdSBleHBlY3QgdGVzdHMgdG8gcHJvZHVjZSB0aGUgc2FtZVxuICAvLyByZXN1bHRzIGZvciBldmVyeW9uZVxuICBOT0RFX0VOViAhPT0gJ3Rlc3QnICYmIGAke3BhdGhzLmRvdGVudn0ubG9jYWxgLFxuICBwYXRocy5kb3RlbnYsXG5dLmZpbHRlcihCb29sZWFuKTtcblxuLy8gTG9hZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSAuZW52KiBmaWxlcy4gU3VwcHJlc3Mgd2FybmluZ3MgdXNpbmcgc2lsZW50XG4vLyBpZiB0aGlzIGZpbGUgaXMgbWlzc2luZy4gZG90ZW52IHdpbGwgbmV2ZXIgbW9kaWZ5IGFueSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbi8vIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0LiAgVmFyaWFibGUgZXhwYW5zaW9uIGlzIHN1cHBvcnRlZCBpbiAuZW52IGZpbGVzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21vdGRvdGxhL2RvdGVudlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21vdGRvdGxhL2RvdGVudi1leHBhbmRcbmRvdGVudkZpbGVzLmZvckVhY2goZG90ZW52RmlsZSA9PiB7XG4gIGlmIChmcy5leGlzdHNTeW5jKGRvdGVudkZpbGUpKSB7XG4gICAgcmVxdWlyZSgnZG90ZW52LWV4cGFuZCcpKFxuICAgICAgcmVxdWlyZSgnZG90ZW52JykuY29uZmlnKHtcbiAgICAgICAgcGF0aDogZG90ZW52RmlsZSxcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufSk7XG5cbi8vIFdlIHN1cHBvcnQgcmVzb2x2aW5nIG1vZHVsZXMgYWNjb3JkaW5nIHRvIGBOT0RFX1BBVEhgLlxuLy8gVGhpcyBsZXRzIHlvdSB1c2UgYWJzb2x1dGUgcGF0aHMgaW4gaW1wb3J0cyBpbnNpZGUgbGFyZ2UgbW9ub3JlcG9zOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvaXNzdWVzLzI1My5cbi8vIEl0IHdvcmtzIHNpbWlsYXIgdG8gYE5PREVfUEFUSGAgaW4gTm9kZSBpdHNlbGY6XG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL21vZHVsZXMuaHRtbCNtb2R1bGVzX2xvYWRpbmdfZnJvbV90aGVfZ2xvYmFsX2ZvbGRlcnNcbi8vIE5vdGUgdGhhdCB1bmxpa2UgaW4gTm9kZSwgb25seSAqcmVsYXRpdmUqIHBhdGhzIGZyb20gYE5PREVfUEFUSGAgYXJlIGhvbm9yZWQuXG4vLyBPdGhlcndpc2UsIHdlIHJpc2sgaW1wb3J0aW5nIE5vZGUuanMgY29yZSBtb2R1bGVzIGludG8gYW4gYXBwIGluc3RlYWQgb2YgV2VicGFjayBzaGltcy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8xMDIzI2lzc3VlY29tbWVudC0yNjUzNDQ0MjFcbi8vIFdlIGFsc28gcmVzb2x2ZSB0aGVtIHRvIG1ha2Ugc3VyZSBhbGwgdG9vbHMgdXNpbmcgdGhlbSB3b3JrIGNvbnNpc3RlbnRseS5cbmNvbnN0IGFwcERpcmVjdG9yeSA9IGZzLnJlYWxwYXRoU3luYyhwcm9jZXNzLmN3ZCgpKTtcbnByb2Nlc3MuZW52Lk5PREVfUEFUSCA9IChwcm9jZXNzLmVudi5OT0RFX1BBVEggfHwgJycpXG4gIC5zcGxpdChwYXRoLmRlbGltaXRlcilcbiAgLmZpbHRlcihmb2xkZXIgPT4gZm9sZGVyICYmICFwYXRoLmlzQWJzb2x1dGUoZm9sZGVyKSlcbiAgLm1hcChmb2xkZXIgPT4gcGF0aC5yZXNvbHZlKGFwcERpcmVjdG9yeSwgZm9sZGVyKSlcbiAgLmpvaW4ocGF0aC5kZWxpbWl0ZXIpO1xuXG4vLyBHcmFiIE5PREVfRU5WIGFuZCBSRUFDVF9BUFBfKiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYW5kIHByZXBhcmUgdGhlbSB0byBiZVxuLy8gaW5qZWN0ZWQgaW50byB0aGUgYXBwbGljYXRpb24gdmlhIERlZmluZVBsdWdpbiBpbiBXZWJwYWNrIGNvbmZpZ3VyYXRpb24uXG5jb25zdCBSRUFDVF9BUFAgPSAvXlJFQUNUX0FQUF8vaTtcblxuZnVuY3Rpb24gZ2V0Q2xpZW50RW52aXJvbm1lbnQocHVibGljVXJsKSB7XG4gIGNvbnN0IHJhdyA9IE9iamVjdC5rZXlzKHByb2Nlc3MuZW52KVxuICAgIC5maWx0ZXIoa2V5ID0+IFJFQUNUX0FQUC50ZXN0KGtleSkpXG4gICAgLnJlZHVjZShcbiAgICAgIChlbnYsIGtleSkgPT4ge1xuICAgICAgICBlbnZba2V5XSA9IHByb2Nlc3MuZW52W2tleV07XG4gICAgICAgIHJldHVybiBlbnY7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgd2XigJlyZSBydW5uaW5nIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgICAgLy8gTW9zdCBpbXBvcnRhbnRseSwgaXQgc3dpdGNoZXMgUmVhY3QgaW50byB0aGUgY29ycmVjdCBtb2RlLlxuICAgICAgICBOT0RFX0VOVjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JyxcbiAgICAgICAgLy8gVXNlZnVsIGZvciByZXNvbHZpbmcgdGhlIGNvcnJlY3QgcGF0aCB0byBzdGF0aWMgYXNzZXRzIGluIGBwdWJsaWNgLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgPGltZyBzcmM9e3Byb2Nlc3MuZW52LlBVQkxJQ19VUkwgKyAnL2ltZy9sb2dvLnBuZyd9IC8+LlxuICAgICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgYXMgYW4gZXNjYXBlIGhhdGNoLiBOb3JtYWxseSB5b3Ugd291bGQgcHV0XG4gICAgICAgIC8vIGltYWdlcyBpbnRvIHRoZSBgc3JjYCBhbmQgYGltcG9ydGAgdGhlbSBpbiBjb2RlIHRvIGdldCB0aGVpciBwYXRocy5cbiAgICAgICAgUFVCTElDX1VSTDogcHVibGljVXJsLFxuICAgICAgfVxuICAgICk7XG4gIC8vIFN0cmluZ2lmeSBhbGwgdmFsdWVzIHNvIHdlIGNhbiBmZWVkIGludG8gV2VicGFjayBEZWZpbmVQbHVnaW5cbiAgY29uc3Qgc3RyaW5naWZpZWQgPSB7XG4gICAgJ3Byb2Nlc3MuZW52JzogT2JqZWN0LmtleXMocmF3KS5yZWR1Y2UoKGVudiwga2V5KSA9PiB7XG4gICAgICBlbnZba2V5XSA9IEpTT04uc3RyaW5naWZ5KHJhd1trZXldKTtcbiAgICAgIHJldHVybiBlbnY7XG4gICAgfSwge30pLFxuICB9O1xuXG4gIHJldHVybiB7IHJhdywgc3RyaW5naWZpZWQgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRDbGllbnRFbnZpcm9ubWVudDtcbiJdfQ==